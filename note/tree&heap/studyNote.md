## TREES 樹狀結構 (Chapter 12)

*   **資料結構與樹的基本組成：** 樹是一種資料結構，其基本組成要素包括**根 (root)**（只有一個）、**分支 (branch)**（兩個以上）以及**層次/階層 (Level/hierarchy)**（多個）。樹在日常生活中的應用包括**家族樹**和**檔案系統階層**。
*   **從線性到階層：** 連結串列（單向或雙向）是線性結構，但如果連結串列中的節點可以有多個指標（例如二元樹節點使用 `left`, `right`），它就能產生分支，從而將線性結構轉換為**階層式結構**。
*   **樹的組成元素：** 資料結構中的樹包含多種組件，例如：**節點 (Node)**（根、內部節點、葉子、父節點、子節點、兄弟節點）、**邊 (Edge)**、**子樹 (Subtree)**、**層次 (Level)**、**深度/高度 (Depth/Height)** 以及**分支度 (Branch/Fan out)**。
*   **樹的定義與術語：** 樹是一種**非線性、階層式資料結構**，由節點和邊組成，並且**不含循環 (no cycles)**。它用於表示階層關係，如檔案系統。其他重要術語包括**葉節點 (leaf)**（沒有子節點的節點）和**兄弟節點 (siblings)**（共享相同父節點的節點）。
*   **深度與高度：** **根節點 (Root)** 是樹的最頂端節點。**葉節點 (Leaf)** 是沒有子節點的節點。**深度 (Depth)** 是節點與根節點的距離。**高度 (Height)** 是從根節點到葉節點的最長路徑。**分支度 (Fan-out/Degree)** 是一個節點可以擁有的子節點數量。

### 樹狀結構基本術語表
樹狀結構是一種非線性的階層式資料結構，由節點和邊組成，且不含循環。以下是其核心術語：

| 術語 | 定義 |
| :--- | :--- |
| **根節點 (Root)** | 樹的最頂端節點。 |
| **葉節點 (Leaf)** | 沒有任何子節點的節點。 |
| **兄弟節點 (Sibling)** | 共享相同父節點的節點。 |
| **邊 (Edge)** | 連接兩個節點的連線。 |
| **深度 (Depth)** | 節點與根節點之間的距離。 |
| **高度 (Height)** | 從節點到葉節點的最長路徑。 |
| **分支度 (Fan-out/Degree)** | 一個節點可以擁有的子節點數量。 |

### 樹的類型 (Types of Trees)

*   **核心/基本類型：**
    *   **滿二元樹 (Full Binary Tree)**：每個節點有 0 或 2 個子節點。
    *   **完全二元樹 (Complete Binary Tree)**：除了最後一層外，所有層次都被填滿，最後一層節點從左到右排列（應用於堆積 Heap）。
    *   **二元搜尋樹 (BST)**：滿足左子節點 < 父節點 < 右子節點的順序性。
    *   **平衡樹 (Balanced Tree)**：例如 AVL/紅黑樹，控制高度差異，用於高效搜尋。
    *   **通用樹 (General Tree)**：節點可以有任意數量的子節點 (例如組織架構)。
*   **進階 I：**
    *   **決策樹 (Decision Tree)**：用於機器學習分類。
    *   **抽象語法樹 (AST)**：表示程式語法結構（編譯器設計）。
    *   **B-Tree / B+ Tree**：多路搜尋樹，專為磁碟/區塊儲存設計，用於**資料庫和檔案系統**。
*   **進階 II：**
    *   **堆積樹 (Heap Tree)**：**完全二元樹**，其中父節點的鍵值滿足順序 ($\geq$ 或 $\leq$ 子節點)，用於**優先權佇列 (Priority Queue)**。
    *   **KD-Tree / Quad Tree / Octree**：用於多維空間分割或圖形處理。

### 常見樹的類型與應用
來源資料中列舉了從基礎到進階的多種樹狀結構：

| 類別 | 類型 | 說明與應用 |
| :--- | :--- | :--- |
| **核心類型** | **滿二元樹 (Full)** | 每個節點有 0 或 2 個子節點；用於機器學習決策節點。 |
| | **完全二元樹 (Complete)** | 除了最後一層外皆填滿，且節點由左至右排列；用於堆積。 |
| | **二元搜尋樹 (BST)** | 滿足「左子 < 父 < 右子」的排序規則；用於搜尋與排序。 |
| | **平衡樹 (Balanced)** | 控制子樹高度差，確保搜尋效率（如 AVL、紅黑樹）。 |
| **進階類型** | **B-Tree / B+ Tree** | 多路搜尋樹，專為磁碟儲存設計；用於資料庫與檔案系統。 |
| | **Trie (前綴樹)** | 字元分支結構；用於字典單字檢索與自動完成。 |
| | **Heap (堆積樹)** | 滿足順序屬性的完全樹；用於優先權佇列。 |
| | **KD-Tree** | 用於 K 維空間分割與最近鄰搜尋。 |

### 樹的層次結構 (Tree Family Hierarchy)

*   **樹到二元搜尋樹：**
    *   **通用樹 (Tree)**：一般階層結構，對子節點數量無限制。
    *   **二元樹 (Binary Tree)**：規定每個節點**最多有兩個子節點**（左、右），這是一個**形狀規則 (shape rule)**。
    *   **二元搜尋樹 (BST)**：在二元樹的基礎上加入**排序規則 (ordering rule)**，即「左子樹 < 根節點 < 右子樹」。
*   **平衡樹與概念層次：**
    *   **平衡二元搜尋樹 (Balanced BST)**（如 AVL / 紅黑樹）：加入額外規則，使樹高接近 $\log n$，以確保**可預測的效能**。
    *   概念層次：樹（形狀最通用）$\rightarrow$ 二元樹（分支度限制）$\rightarrow$ BST（排序不變量）$\rightarrow$ 平衡 BST（高度/平衡不變量）。

### 樹的遍歷 (Tree Traversal)

*   **遍歷類型：** 遍歷是按照特定順序訪問每個節點的過程。主要分為：**深度優先遍歷 (DFT)** 和**廣度優先遍歷 (BFT)**。
*   **深度優先遍歷 (DFT)：**
    *   **前序 (Preorder, 根–左–右)**：用於複製樹。
    *   **中序 (Inorder, 左–根–右)**：在 BST 中可以得到**排序好的順序**。
    *   **後序 (Postorder, 左–右–根)**：用於刪除或釋放記憶體。
*   **廣度優先遍歷 (BFT)：** BFT 又稱**層次遍歷 (Level-Order Traversal)**，使用佇列 (queue) 逐層訪問節點。

### 樹的遍歷 (Traversal) 方式比較
遍歷是以特定順序訪問樹中所有節點的過程。

| 遍歷類別 | 順序名稱 | 訪問路徑 | 典型用途 |
| :--- | :--- | :--- | :--- |
| **深度優先 (DFT)** | **前序 (Preorder)** | 根 $\rightarrow$ 左 $\rightarrow$ 右 | 用於複製整棵樹。 |
| | **中序 (Inorder)** | 左 $\rightarrow$ 根 $\rightarrow$ 右 | 在 BST 中可依序輸出排序好的資料。 |
| | **後序 (Postorder)** | 左 $\rightarrow$ 右 $\rightarrow$ 根 | 用於刪除節點或釋放記憶體。 |
| **廣度優先 (BFT)** | **層序 (Level-Order)** | 逐層訪問 (使用佇列) | 依層級深度依序訪問。 |

### 樹的表示法與平衡 (Representation and Balance)

*   **樹的表示法與轉換：** 通用樹可以通過**清單表示法 (List representation)** 或**左子節點-右兄弟節點表示法 (Left child-right sibling representation)** 來表示。通過**左子節點-右兄弟節點表示法**，可以將通用樹轉換為二元樹 (Degree-Two Tree)。
*   **平衡問題：** 平衡樹能確保子樹之間的高度差最小化。如果樹變得**不平衡 (Unbalanced)** 或**歪斜 (Skewed/Degenerate)**，搜尋和插入操作的效能會從 $O(\log n)$ 退化到 **$O(n)$**。
*   **平衡策略與複雜度總結：** **AVL 樹**要求高度差 $\leq 1$。**紅黑樹**通過顏色限制來實現平衡。保持平衡的樹，其搜尋/插入複雜度為 $\mathbf{O(\log n)}$。遍歷複雜度（DFT/BFT）為 $\mathbf{O(n)}$。

### 二元樹與二元搜尋樹 (Binary Tree vs. BST)

*   **二元樹 ADT：** 二元樹是一種抽象資料型別 (ADT)，若非空，則由一個根節點、一個左二元子樹和一個右二元子樹組成。**二元樹**的定義是每個節點**最多有兩個子節點**。
*   **BST 特性：** **二元樹**只基於**形狀定義**，對節點的值沒有排序限制。**二元搜尋樹 (BST)** 則在二元樹的基礎上加入了**排序屬性 (ordering property)**：對於任何節點，其左子樹中的所有值都小於該節點的值，右子樹中的所有值都大於該節點的值。
*   **BST 的插入與刪除：**
    *   插入操作的複雜度為 $O(h)$，平衡時為 $\mathbf{O(\log n)}$，最差情況（歪斜）為 $\mathbf{O(n)}$。
    *   刪除內部節點（有兩個子節點）時，替代節點通常選擇**左子樹的最大值 (中序前驅)** 或**右子樹的最小值 (中序後繼)**。
    *   刪除操作的整體複雜度為 $O(h)$，平衡時為 $\mathbf{O(\log n)}$，歪斜時為 $\mathbf{O(n)}$。
*   **AVL 樹：** **AVL 樹**是一種**自平衡二元搜尋樹**，它要求樹中每個節點的左右子樹高度差**至多為 1** ($|h_L – h_R| \leq 1$)。這是從 BST 發展到**高度平衡 (Height-balanced)** 的一個特化。

## HEAPS 堆積 (Chapter 13)

*   **堆積的兩大特性：**
    *   **形狀特性 (Shape property)：** 堆積必須是**完全二元樹 (Complete Binary Tree)**。這個特性保證了堆積可以被**高效地儲存在陣列中**（沒有間隙）。
    *   **堆積順序特性 (Heap-Order Property)：**
        *   **最大堆積 (Max heap)**：父節點的鍵值**總是 $\geq$ 子節點**；最大元素總在根節點。
*   **最小堆積與應用：** **最小堆積 (Min heap)**：父節點的鍵值**總是 $\leq$ 子節點**；最小元素總在根節點。堆積通常用於實作**優先權佇列 (Priority Queue)** 和**堆積排序 (Heapsort)**。
*   **堆積操作與複雜度：** 插入 (`insert`) 和取出根節點 (`extract_root`) 的時間複雜度均為 $\mathbf{O(\log n)}$。檢視根節點 (`peek_root`) 為 $\mathbf{O(1)}$。
*   **優先權：** 在堆積中，**鍵值 (Key value)** 代表優先權。根節點 (Root node) 總是擁有**最高優先權**的元素。
*   **插入與取出操作細節：**
    *   **插入 (sift-up 上濾)**：將新節點插入到最左邊的空位，維持完全樹形狀。然後與父節點比較並交換，直到滿足堆積順序或到達根節點。
    *   **取出最大值 (sift-down 下濾)**：將根節點替換為**最後一個葉節點**，維持完全樹形狀。然後與**較大的子節點**比較並交換，直到滿足堆積順序或到達葉節點。
*   **堆積複雜度總結：** 插入 (sift-up) 和取出 (sift-down) 均為 $\mathbf{O(\log n)}$。從陣列建構堆積 (`build-heap`) 為 $\mathbf{O(n)}$。堆積排序 (`heapsort`) 為 $\mathbf{O(n \log n)}$。

### 堆積 (Heap) 的操作與複雜度
堆積是一種完全二元樹，其父節點與子節點間存在固定的優先權順序（最大堆積或最小堆積）。

| 操作項目 | 說明 | 時間複雜度 |
| :--- | :--- | :--- |
| **Insert (插入)** | 在最後一個位置加入新元素並執行 **sift-up (上濾)**。 | $O(\log n)$ |
| **Extract Root (取出根)** | 移除根節點，用最後一個葉子遞補並執行 **sift-down (下濾)**。 | $O(\log n)$ |
| **Peek Root (檢視根)** | 直接讀取根節點的值（最高或最低優先權）。 | $O(1)$ |
| **Build Heap (建構)** | 將一組陣列轉換為堆積結構（Floyd 演算法）。 | $O(n)$ |
| **Heapsort (堆積排序)** | 透過連續取出最大值來排序。 | $O(n \log n)$ |

### 平衡樹與搜尋複雜度總結
來源資料特別強調「平衡」對效能的影響。當二元搜尋樹變得歪斜（Skewed）時，效能會大幅退化。

| 樹的狀態 | 搜尋/插入複雜度 | 說明 |
| :--- | :--- | :--- |
| **平衡 (Balanced)** | $O(\log n)$ | 樹的高度維持在 $\log n$，搜尋效率極佳。 |
| **歪斜 (Skewed)** | $O(n)$ | 結構退化成類似連結串列，效能最差。 |
| **AVL 樹** | $O(\log n)$ | 自平衡 BST，確保任何節點的左右子樹高度差 $\leq 1$。 |

您可以將樹狀結構想像成一間**圖書館的索引分類系統**：如果書架（樹）分佈均勻（平衡），您只需要幾次轉彎（步驟）就能找到書；但如果所有書都堆在一條長廊（歪斜），您就得從頭走到尾才能找到目標。
