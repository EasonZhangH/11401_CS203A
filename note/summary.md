# 「 資料結構筆記 」總整理 & 比較分析
---

## 一、核心資料結構概覽與連結

資料結構是電腦儲存、組織資料的方式，它們決定了資料存取和操作的效率。以下是本課程涵蓋的主要資料結構及其詳細筆記連結：

| 資料結構類別 | 核心概念 | 相關筆記連結 |
| :--- | :--- | :--- |
| **線性結構** | 元素按順序排列，一對一關係。 | [陣列 (Array)](./array/summary.md) |
| | | [鏈結串列 (Linked List)](./linkedList/summary.md) |
| | | [佇列與堆疊 (Queue & Stack) 筆記](./queue&stack/studyNote.md) |
| **雜湊結構** | 透過雜湊函數實現快速查找。 | [雜湊表 (Hash Table) 總結](./hash/summary.md) |
| | | [雜湊表 (Hash Table) 筆記](./hash/studyNote.md) |
| **樹狀結構** | 元素呈階層式排列，一對多關係。 | [樹與堆 (Tree & Heap) 總結](./tree&heap/summary.md) |
| | | [樹與堆 (Tree & Heap) 筆記](./tree&heap/studyNote.md) |
| **圖狀結構** | 元素間存在任意多對多關係。 | [圖 (Graph) 總結](./graph/summary.md) |
| | | [圖 (Graph) 筆記](./graph/studyNote.md) |

---

## 二、資料結構的演化與過渡過程

資料結構的發展是一個不斷優化特定操作效能的過程。從最基礎的線性結構開始，透過增加結構複雜度來換取時間效率。

### 1. 線性結構的演化：從連續到分散，追求彈性與查找速度

| 演化階段 | 結構 | 核心問題 | 解決方案 |
| :--- | :--- | :--- | :--- |
| **基礎連續** | **陣列 (Array)** | 插入/刪除操作需要移動大量元素，效率低 $O(N)$。 | 透過索引實現 $O(1)$ 隨機存取。 |
| **基礎分散** | **鏈結串列 (Linked List)** | 隨機存取效率低 $O(N)$。 | 插入/刪除操作效率高 $O(1)$，透過指標實現彈性記憶體分配。 |
| **高效查找** | **雜湊表 (Hash Table)** | 查找效率仍受限於 $O(N)$ (最差情況)。 | 透過雜湊函數，將查找效率提升至平均 $O(1)$。 |

**過渡說明:**
陣列提供了最快的隨機存取，但犧牲了修改效率。鏈結串列犧牲了隨機存取，換取了高效的修改。**雜湊表**則試圖結合兩者優點，利用雜湊函數將資料直接映射到記憶體位置，從而實現近乎 $O(1)$ 的查找、插入和刪除。

### 2. 複雜結構的演化：從階層到網路，處理複雜關係

| 演化階段 | 結構 | 核心問題 | 解決方案 |
| :--- | :--- | :--- | :--- |
| **階層關係** | **樹 (Tree)** | 處理階層數據，如檔案系統、組織架構。 | 透過父子節點關係，實現 $O(\log N)$ 的查找（如在平衡二元搜尋樹中）。 |
| **優化優先權** | **堆 (Heap)** | 樹的查找功能不適用於快速取得最大/最小元素。 | 犧牲通用查找能力，專注於 $O(1)$ 取得極值和 $O(\log N)$ 插入/刪除極值。 |
| **任意關係** | **圖 (Graph)** | 樹結構無法表達任意節點間的多對多關係。 | 透過節點和邊的抽象，模擬現實世界中複雜的網路關係。 |

**過渡說明:**
**樹**是表達階層關係的強大工具。**堆**是樹結構的一個特例，它根據「堆序性」進行組織，專門用於實現優先權佇列。**圖**則是樹的泛化，樹可以看作是一種特殊的圖（無環連通圖），圖結構允許節點間存在任意數量的邊，是處理網路、地圖、社交關係等複雜問題的基礎。

---

## 三、核心資料結構效能比較

以下表格比較了幾種關鍵資料結構在時間複雜度（最差情況）和空間複雜度上的差異。

### 1. 時間複雜度比較 (Worst Case)

| 資料結構 | 隨機存取 (Access) | 查找 (Search) | 插入 (Insertion) | 刪除 (Deletion) |
| :--- | :--- | :--- | :--- | :--- |
| **陣列 (Array)** | $O(1)$ | $O(N)$ | $O(N)$ | $O(N)$ |
| **鏈結串列 (Linked List)** | $O(N)$ | $O(N)$ | $O(1)$ (已知位置) / $O(N)$ (查找後) | $O(1)$ (已知位置) / $O(N)$ (查找後) |
| **雜湊表 (Hash Table)** | N/A | $O(N)$ | $O(N)$ | $O(N)$ |
| **平衡二元搜尋樹 (AVL/Red-Black Tree)** | $O(\log N)$ | $O(\log N)$ | $O(\log N)$ | $O(\log N)$ |
| **堆 (Heap)** | N/A | $O(N)$ | $O(\log N)$ | $O(\log N)$ (刪除最大/最小) |
| **圖 (Graph)** | N/A | $O(V+E)$ (遍歷) | $O(1)$ (新增節點/邊) | $O(1)$ (刪除節點/邊) |

*註：雜湊表的平均時間複雜度為 $O(1)$，但在最差情況（所有元素雜湊衝突）下會退化為 $O(N)$。*

### 2. 空間複雜度比較

| 資料結構 | 空間複雜度 | 額外空間開銷 | 備註 |
| :--- | :--- | :--- | :--- |
| **陣列** | $O(N)$ | $O(1)$ | 儲存資料本身，無額外指標開銷。 |
| **鏈結串列** | $O(N)$ | $O(N)$ | 每個節點需要額外空間儲存指標。 |
| **雜湊表** | $O(N)$ | $O(N)$ | 儲存雜湊表本身和處理衝突的結構（如鏈結串列）。 |
| **樹/堆** | $O(N)$ | $O(N)$ | 每個節點需要額外空間儲存父/子節點指標。 |
| **圖** | $O(V+E)$ | $O(V+E)$ | 鄰接矩陣為 $O(V^2)$，鄰接串列為 $O(V+E)$。 |

---

## 四、資料結構的組合應用與設計模式


在實際的系統設計中，很少單獨使用一個資料結構。通常會將多個結構組合起來，以發揮各自的優勢，解決複雜的現實問題。

### 1. LRU Cache (最近最少使用快取)

| 組合結構 | 目的 |
| :--- | :--- |
| **雙向鏈結串列 (Doubly Linked List)** | 保持資料的「使用順序」。最近使用的節點移到串列頭部，最少使用的節點保留在尾部。實現 $O(1)$ 的插入和刪除。 |
| **雜湊表 (Hash Map)** | 實現 $O(1)$ 的快速查找。鍵 (Key) 映射到鏈結串列中的節點 (Node) 地址。 |

**運作原理:**
當存取一個元素時，先用雜湊表 $O(1)$ 查找。若找到，則將對應的鏈結串列節點 $O(1)$ 移到頭部。若快取滿了需要淘汰，則 $O(1)$ 刪除鏈結串列尾部的節點。

### 2. 圖演算法中的組合：Dijkstra/Prim

| 組合結構 | 目的 |
| :--- | :--- |
| **圖 (Graph)** | 儲存節點和帶權重的邊，表示網路結構。 |
| **優先權佇列 (Priority Queue / Heap)** | 在尋找最短路徑或最小生成樹時，高效地選取下一個權重最小的節點。實現 $O(\log N)$ 的提取最小元素。 |

**運作原理:**
Dijkstra 演算法使用優先權佇列來儲存待處理的節點及其當前最短距離。每次從佇列中取出距離最小的節點，確保了貪婪選擇的正確性，並將整體時間複雜度優化到 $O((V+E) \log V)$。

### 3. 符號表 (Symbol Table) 的實現

| 組合結構 | 目的 |
| :--- | :--- |
| **陣列/鏈結串列** | 處理雜湊衝突 (Chaining)。 |
| **平衡二元搜尋樹 (BST)** | 作為雜湊表中的桶 (Bucket)，當衝突嚴重時，將鏈結串列替換為 BST，將最差查找時間從 $O(N)$ 降至 $O(\log N)$ (如 Java 8+ 的 `HashMap`)。 |

**運作原理:**
現代高效的雜湊表（如 `std::unordered_map` 或 `HashMap`）在雜湊衝突的鏈結串列長度超過一定閾值時，會自動將該鏈結串列轉換為紅黑樹 (Red-Black Tree)，以保證最差情況下的查找效率。

---

## 五、結論

掌握資料結構的關鍵在於理解它們的**抽象資料類型 (ADT)**、**底層實現**和**效能權衡**。

| 結構 | 適用場景 | 核心權衡 |
| :--- | :--- | :--- |
| **陣列** | 數據量固定、需要大量隨機存取。 | 存取速度 vs. 修改成本 |
| **鏈結串列** | 數據量不固定、需要大量插入/刪除。 | 修改成本 vs. 存取速度 |
| **雜湊表** | 需要極速查找、插入、刪除。 | 空間開銷 vs. 查找速度 |
| **平衡樹** | 需要有序數據、高效查找、範圍查詢。 | 實現複雜度 vs. 效能穩定性 |
| **堆** | 需要快速獲取極值（最大/最小）。 | 通用性 vs. 優先權操作速度 |
| **圖** | 處理複雜網路關係、路徑尋找。 | 建模能力 vs. 演算法複雜度 |

建議在學習時，不僅要記憶複雜度，更要理解**為什麼**某個結構能達到某種複雜度，以及在特定應用中，**哪種結構的組合**能提供最佳的整體效能。
