## GRAPH 圖(Chapter 14)
### 來源
*   **圖形結構（Graphs）**：圖形是資料結構的第六章主題，並透過真實世界範例來說明其應用，例如 **Google 地圖**上的路線規劃（起點：YZU Library；終點：Neili Station）。
*   **歷史與基礎**：圖形的概念與著名的**柯尼斯堡七橋問題**（Seven Bridges of Königsberg）相關，此問題由數學家李昂哈德·歐拉（Leonhard Euler）提出。
*   **離散數學中的圖形定義**：一個圖形 $G$ 定義為 $(V, E)$。
    *   **V**：一組**頂點**（vertices），也稱為節點（nodes）或點（points）。
    *   **E**：一組**邊**（edges），也稱為連結（links）或線（lines），它們是頂點的無序對 $\{x, y\}$ 集合，其中 $x ≠ y$。

### 圖的基本概念
*   **圖形的概念**：圖形是一組由邊連接起來的頂點（節點）集合，用於表示實體之間的關係。
*   **柯尼斯堡問題的圖形化**：柯尼斯堡七橋的實際地圖被抽象化為一個只有四個頂點和七條邊的圖形模型。
*   **圖形表示方法介紹**：提出了使用**鄰接矩陣**（Adjacency Matrix）來表示圖形的概念。鄰接矩陣 $Array[i][j]$ 的值代表了頂點 $i$ 和頂點 $j$ 之間橋樑/邊的數量。

### 圖跟樹的比較
*   **圖形 vs. 樹狀結構**：與樹狀結構不同，圖形可以包含**循環**（cycles），且其邊可以是**有向**（directed）或**無向**（undirected）的。
*   **圖形的應用**：圖形可用於建模各種網絡，例如社交連接、交通運輸系統或帶有超連結的網頁。
*   **圖形組成要素**：圖形的基本組成要素包括節點（頂點）、邊、帶有**方向**的邊、帶有**權重**（weight）的邊，以及帶有標籤的節點/邊。
*   **圖形結構類型**：資料中以圖示說明了幾種圖形結構，包括樹狀結構（Tree）、連通圖（Connected Graph）、自環（Self edge）、多重圖（Multigraph），以及有向圖（Directed graph / digraph）。

### 圖基本術語表
*   **子圖（Subgraph）**：圖形 $G$ 的子圖 $G’$ 必須滿足 $V(G’) \subseteq V(G)$ 且 $E(G’) \subseteq E(G)$。
*   **度（Degree）**：一個頂點的度是與該頂點相關聯的邊的數量。
*   **有向圖中的度**：
    *   **入度（In-degree）**：指向該頂點 $v$ 的邊的數量。
    *   **出度（Out-degree）**：從該頂點 $v$ 出發的邊的數量。
*   **同構性（Isomorphism）**：資料提到了圖形的同構性概念。
---
### 圖分類
*   **圖形分類（Classification）**：圖形可以根據其特性進行分類，並給出了範例：
    *   **無向圖**（Undirected Graph）：邊無方向，如朋友網絡。
    *   **有向圖**（Directed Graph/Digraph）：邊有方向，如 Instagram 追蹤。
    *   **加權圖**（Weighted Graph）：每條邊有成本/權重，如 Google 地圖距離。
    *   **無權圖**（Unweighted Graph）：所有邊權重相等。
    *   **循環圖**（Cyclic Graph）：包含循環，如城市環狀道路。
    *   **無環圖**（Acyclic Graph）：不含循環，如家庭樹。
    *   **連通圖**（Connected Graph）：所有節點可到達，如道路網絡。
    *   **非連通圖**（Disconnected Graph）：部分節點被隔離。

### 圖分類與實例對照表
圖形可根據其邊的方向、權重與連通性進行分類。

| 圖形類型 | 描述 | 實際應用範例 |
| :--- | :--- | :--- |
| **無向圖 (Undirected)** | 邊沒有特定方向 | 社交網路中的朋友關係 |
| **有向圖 (Directed)** | 邊具有方向性（從起點到終點） | Instagram 的「追蹤」功能 |
| **加權圖 (Weighted)** | 每條邊都有對應的成本或數值 | Google 地圖上的行車距離 |
| **無權圖 (Unweighted)** | 所有邊的權重皆相等 | 棋盤遊戲地圖 |
| **循環圖 (Cyclic)** | 圖中包含閉合迴路 | 城市內的環狀道路 |
| **無環圖 (Acyclic)** | 圖中不包含任何循環 | 家族族譜（家庭樹） |
| **連通圖 (Connected)** | 任意兩個節點間皆有路徑可達 | 健全的道路網路 |
| **非連通圖 (Disconnected)** | 部分節點被隔離，無法到達其他區域 | 沒有橋樑連接的群島 |

### 圖的表示方法
*   **圖形表示法（Graph Representation）**：常見的圖形表示方法包括**鄰接矩陣**（Adjacency Matrix）和**鄰接串列**（Adjacency List）。
*   **鄰接矩陣**：以一個範例圖形（節點 0 到 3）展示了鄰接矩陣的結構。
*   **鄰接串列**：以一個範例圖形展示了鄰接串列的結構，其中每個頂點儲存了其鄰居的列表。
---
### 鄰接矩陣
*   **鄰接矩陣的優點**：
    *   **O(1) 邊查找**：通過 `matrix[u][v]` 立即得知邊是否存在。
    *   **實作簡單**：易於編碼和視覺化。
    *   適用於**稠密圖**（Dense graphs，邊很多）。
    *   適用於需要快速存取的演算法，如 Floyd–Warshall。
    *   天然適合儲存加權圖的權重。
*   **鄰接矩陣的缺點**：
    *   **O(V²) 空間**：即使邊很少，空間開銷也很大。
    *   對**稀疏圖**（Sparse graphs，邊很少，大多數真實世界的圖形）而言，存在空間浪費。
    *   獲取鄰居需要掃描整行，時間複雜度為 O(V)。
    *   難以動態插入/刪除頂點。
    *   **最佳應用**：稠密圖或快速邊查找重要的圖形。
### 鄰接串列
*   **鄰接串列的優點**：
    *   **O(V + E) 空間**：非常適合稀疏圖。
    *   **快速遍歷**：存取頂點的鄰居只需 O(deg(v)) 時間。
    *   對 BFS/DFS 等演算法極為高效，複雜度為 O(V + E)。
    *   易於擴展到大型圖形。
    *   插入/刪除邊的時間複雜度為 O(1)。


*   **鄰接串列的缺點**：
    *   檢查邊 $(u, v)$ 是否存在需要 O(deg(u)) 時間。
    *   實作上略微複雜。
    *   如果使用許多小型鏈結串列節點，會有記憶體開銷。
    *   **最佳應用**：稀疏圖（大多數真實世界的圖形，如社交網絡、地圖）、以及適合 BFS/DFS、Dijkstra、Prim、Kruskal 等演算法的場合。
*   **稀疏矩陣與稀疏串列的比較**：稀疏矩陣（大部分為零）的有效表示法是鄰接串列。
---  
### 時間複雜度
*   **時間複雜度比較表**：對鄰接矩陣和鄰接串列在幾個特徵上的時間和空間複雜度進行了直接對比。
    *   邊查找：矩陣為 O(1)，串列為 O(deg(v))。
    *   空間：矩陣為 O(V²)，串列為 O(V + E)。
    *   BFS/DFS 遍歷：矩陣為 O(V²)，串列為 O(V + E)。
    *   最佳應用：矩陣適用於稠密圖，串列適用於稀疏圖。
*   **圖形抽象資料型態（ADT: Graph）**：定義了圖形 ADT 的物件（頂點集和無向邊集）。
  
### 圖形表示法：鄰接矩陣 vs. 鄰接串列
根據圖形的疏密程度（Sparse or Dense），選擇適合的資料結構至關重要。

| 特徵 | **鄰接矩陣 (Adjacency Matrix)** | **鄰接串列 (Adjacency List)** |
| :--- | :--- | :--- |
| **空間複雜度** | **$O(V^2)$**（即使邊很少也佔空間） | **$O(V + E)$**（適合稀疏圖） |
| **邊查找 (u, v)** | **$O(1)$**（極快） | $O(deg(u))$（需掃描鄰居列表） |
| **遍歷 (BFS/DFS)** | $O(V^2)$ | **$O(V + E)$**（極高效） |
| **插入/刪除邊** | $O(1)$ | $O(1)$ (插入) / $O(deg(u))$ (刪除) |
| **適合場景** | **稠密圖 (Dense)**、需要快速邊查找 | **稀疏圖 (Sparse)**、大多數現實世界網路 |
| **實作難度** | 簡單、易於視覺化 | 中等、涉及指標與節點操作 |

---
### ADT -
*   **圖形 ADT 函數**：列出了圖形 ADT 的基本操作函數，包括 `Create()`、`InsertVertex()`、`InsertEdge()`、`DeleteVertex()`、`DeleteEdge()`、`IsEmpty()`，以及 `Adjacent(graph, v)`（返回與 $v$ 鄰接的所有頂點串列）。
*   **圖形定義重申**：圖形 $G(V, E)$ 由頂點集 $V$ 和連接頂點的邊集 $E$ 組成。
---
### 圖走訪策略
*   **圖走訪/圖搜尋（Graph Traversal / Graph Search）**：與樹狀結構一樣，圖形也可以使用**深度優先走訪**（DFS）和**廣度優先走訪**（BFS）進行遍歷。
*   **圖形 vs. 樹狀結構（走訪）**：
    *   **圖形**：通用結構，可以有循環，任意形狀。
    *   **樹狀結構**：是一種連通的**無環圖**（connected acyclic graph）。
    *   **相似點**：走訪都使用「已走訪策略」（visited strategy）、遞迴的 DFS 方法、基於佇列（queue）的 BFS 方法，以及系統性的節點探索。
---
### 圖形 (Graph) 與 樹狀結構 (Tree) 之比較
樹狀結構本質上是圖形的一種特例（連通且無環）。

| 特性 | **樹狀結構 (Tree)** | **圖形 (Graph)** |
| :--- | :--- | :--- |
| **連通性** | 始終連通 | 可能存在非連通分量 |
| **循環** | **無循環** | **允許循環** |
| **階層關係** | 具有明確的父子關係與層次 | **無固有的階層結構** |
| **路徑** | 兩節點間僅有一條路徑 | 兩節點間可能有多條路徑 |
| **走訪策略** | 不需要 `visited[]` 陣列 | **必須使用 `visited[]`** 以避免無限循環 |
| **走訪目標** | 層次化訪問 | 探索連通性、最短路徑、檢測循環 |

---
### 走訪演算法
*   **走訪演算法比較**：樹狀走訪的 Preorder 相當於圖形的 DFS；Level-order 相當於圖形的 BFS。
*   **圖形走訪的關鍵**：圖形走訪 = 樹狀走訪 + **`visited[]`** 陣列/集合，用於**避免循環**（cycles）。

### BFS
*   **圖形 BFS 演算法**：
    1.  建立一個空的佇列（queue）和一個空的已走訪集合（visited set）。
    2.  將起始頂點加入佇列。
    3.  當佇列不為空時：取出頂點 $v$；如果 $v$ 尚未被走訪，則標記 $v$ 為已走訪並輸出；將 $v$ 所有未走訪的鄰居加入佇列。
*   **BFS 與樹狀走訪**：這與樹狀結構的層級走訪（level-order traversal）相同，但圖形由於可能有循環，因此**必須檢查 `visited` 集合**。

### DFS
*   **圖形 DFS 演算法（續）**：如果彈出的頂點 $v$ 尚未被走訪，則標記 $v$ 為已走訪並輸出；將 $v$ 所有未走訪的鄰居推入堆疊（推入順序會影響輸出順序）。
*   **DFS 關鍵點**：與樹狀結構不同，圖形可能會重複訪問節點，因此**必須追蹤已走訪的節點**。
*   **DFS 使用堆疊的原因**：提供**路徑記憶**（Path memory）和**回溯記憶**（Backtracking memory），以便記住從哪裡恢復探索。
*   **圖形走訪必須處理的複雜性**：循環、多個進入路徑、任意拓撲、非連通分量、有向邊（入度和出度），以及邊權重（用於最短路徑問題）。

### DFS VS BFS
*   **BFS 使用佇列的原因**：為了保持層級順序（Level order），即先進先出（FIFO）特性，實現按度數（degree）的走訪。
*   **圖形 DFS 演算法**：
    1.  建立一個空的堆疊（stack）和一個空的已走訪集合。
    2.  將起始頂點推入堆疊。
    3.  當堆疊不為空時：從堆疊中彈出頂點 $v$。
---
### 圖形走訪演算法：BFS vs. DFS
這兩種走訪方式在實作機制與記憶功能上有所不同。

| 特性 | **廣度優先搜尋 (BFS)** | **深度優先搜尋 (DFS)** |
| :--- | :--- | :--- |
| **使用資料結構** | **佇列 (Queue)** | **堆疊 (Stack)** 或 遞迴 |
| **核心機制** | 按層級走訪 (Level-order) | 沿著路徑深入直到回溯 (Backtracking) |
| **樹狀走訪對等** | 相當於層序遍歷 (Level-order) | 相當於前序遍歷 (Preorder) |
| **走訪順序基礎** | 依據節點的**度 (Degree)** | 依據路徑的探索深度 |
| **記憶功能** | 保持層級順序 (FIFO) | 路徑記憶與**回溯記憶** |

---
### 圖的各種特性
*   **圖形走訪的差異點**：詳細比較了圖形和樹狀結構在走訪上的根本不同。
    *   **循環**：樹無循環，圖有循環，因此圖形走訪必須使用 `visited[]`。
    *   **父子關係**：樹有定義，圖形沒有，因此圖形走訪沒有固有的層次結構。
    *   **方向**：樹通常是無向無環的，圖形可以是有向或無向的，因此圖形走訪中入度/出度很重要。
    *   **連通性**：樹始終連通，圖形可能非連通，因此圖形需要針對每個分量執行完整的走訪。
    *   **目標**：樹走訪以層次結構訪問為主，圖形走訪則用於探索連通性、最短路徑、搜索或循環檢測。
