# LeetCode Daily 2025/11/27 筆記

## 題目：Maximum K-Divisible Components (LeetCode 2872)

### 題目描述
- 給定樹的邊和節點值
- 將樹分割成最多的連通分量，使每個分量的節點值和能被 k 整除

---

### 觀察
- 使用 DFS 計算每個子樹的和
- 如果子樹和能被 k 整除，可以分割出一個分量
- 遞迴累加可分割的分量數

---

### 程式碼 (C++)

```cpp
struct Graph{
    int numNode;
    vector<vector<int>> adj;
    Graph(int n, const vector<vector<int>>& edges) : numNode(n), adj(n) {
        for(vector<int> edge : edges) {
            adj[ edge[0] ].push_back(edge[1]);
            adj[ edge[1] ].push_back(edge[0]);
        }
    }
};
class Solution {
public:
    int maxKDivisibleComponents(int n, vector<vector<int>>& edges, vector<int>& values, int k) {
        int ans = 0;
        Graph g(n, edges);
        dfs(g, 0, -1, values, k, ans);
        return ans;
    }
private:
    long long dfs(Graph& g, int u, int prev, vector<int>& values, int k, int& ans) {
        long long sum = values[u];
        for(int v : g.adj[u]) {
            if(v != prev)
                sum += dfs(g, v, u, values, k, ans);
        }
        if(sum % k == 0)
            ans++;
        return sum;
    }
};
```
