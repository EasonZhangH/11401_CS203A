
# LeetCode Daily 2025/12/10 筆記

## 題目：Count the Number of Computer Unlocking Permutations (LeetCode 3577)
---

## 題目描述
- 有 \(n\) 台電腦，標籤 \(0 \sim n-1\)。  
- 電腦 0 的密碼已經解開，作為 root。  
- 要解鎖電腦 \(i\)，必須先有一台 \(j < i\) 且 \(complexity[j] < complexity[i]\) 的電腦已經解鎖。  
- 問：有多少個排列（permutation）代表一個合法的解鎖順序。  

---

## 觀察
1. **電腦 0 是唯一的 root**  
   所有解鎖過程必須從電腦 0 開始。排列的第一個元素必然是 0。  

2. **解鎖條件的本質**  
   - 電腦 \(i\) 必須找到一個 index 更小、且 complexity 更小的電腦。  
   - 由於 root 是 index = 0，若 `complexity[0]` 不比其他電腦小，那麼某些電腦就無法被解鎖。  

3. **必要條件**  
   - 如果存在某個 \(i > 0\)，使得 `complexity[i] <= complexity[0]`，那麼電腦 \(i\) 永遠無法解鎖（因為唯一比它 index 小的就是 0，但 complexity 不小於它）。  
   - 所以必須滿足：`complexity[0] < complexity[i]` 對所有 \(i > 0\)。  

4. **排列數量**  
   - 當上述條件成立時，所有其他 \(n-1\) 台電腦都可以透過 root 解鎖。  
   - 因此它們之間的順序可以任意排列。  
   - 所以答案就是 \((n-1)!\)。  

---

## 與程式碼的對應
```cpp
class Solution {
public:
    int countPermutations(vector<int>& complexity) {
        const int MOD = 1e9 + 7;
        int n = complexity.size();
        
        // 檢查 root 是否比所有其他電腦複雜度小
        for(int i = 1; i < n; i++)
            if(complexity[0] >= complexity[i])
                return 0;
        
        // 計算 (n-1)! % MOD
        long long ans = 1;
        for(int i = 1; i < n; i++)  
            ans = (ans * i) % MOD;
        
        return (int)ans;
    }
};
```

- **檢查條件**：`complexity[0] >= complexity[i]` → 回傳 0。  
- **計算階乘**：迴圈乘上 \(1,2,...,(n-1)\)。  
- **取模**：避免 overflow。  

---

## 時間複雜度分析
- 條件檢查：\(O(n)\)。  
- 階乘計算：\(O(n)\)。  
- 總時間：\(O(n)\)。  
- 空間：\(O(1)\)。  

---

## 舉例驗證
- Input: `[1,2,3]`  
  - `complexity[0] = 1`，比其他都小。  
  - 答案 = \((3-1)! = 2\)。  
  - 符合範例。  

- Input: `[5,6,7]`  
  - `complexity[0] = 5`，比其他都小。  
  - 答案 = \((3-1)! = 2\)。  

- Input: `[5,4,7]`  
  - `complexity[1] = 4` 不大於 5 → 無法解鎖 → 答案 = 0。  

---
