# LeetCode Daily 2025/11/01 筆記

## 題目：Count Unguarded Cells in the Grid (LeetCode 2257)

### 題目描述
- 給定一個 m×n 的網格，有守衛和牆壁
- 守衛可以看到四個方向，直到遇到牆壁或另一個守衛為止
- 計算有多少格子是未被守衛看到的

---

### 觀察
- 使用 DFS 從每個守衛位置向四個方向延伸
- 用不同的值標記：-1 表示牆壁，-2 表示守衛，1 表示被看到
- 最後計算剩餘未被標記的格子數量

---

### 程式碼 (C++)

```cpp
class Solution {
public:
    int dir[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };
    int total, tm, tn;

    bool isValid(int x, int y, vector<vector<int>>& tmp){ 
        if( x >= tm || x < 0 || y >= tn || y < 0 || tmp[x][y] == -2 || tmp[x][y] == -1 ) 
            return false;
        else
            return true;
    }

    void DFS(vector<vector<int>>& tmp, int x, int y) {
        for(int i = 0; i < 4; i++) {
            int curX = x + dir[i][0];
            int curY = y + dir[i][1];
            while(isValid(curX, curY, tmp)){
                if(tmp[curX][curY] == 0) {
                    tmp[curX][curY] = 1;
                    total--;
                }
                curX += dir[i][0];
                curY += dir[i][1];
            }
        }
    }
    
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<vector<int>> tmp(m, vector<int>(n, 0));
        total = m*n, tm = m, tn = n;

        for(int i = 0; i < walls.size(); i++){ 
            int x = walls[i][0], y = walls[i][1];
            tmp[x][y] = -1;
            total--;
        }

        for(int i = 0; i < guards.size(); i++){ 
            int x = guards[i][0], y = guards[i][1];
            tmp[x][y] = -2;
            total--;
        }

        for(int i = 0; i < guards.size(); i++) {
            int curX = guards[i][0], curY = guards[i][1];
            DFS(tmp, curX, curY);
        }

        return total;
    }
};
```
