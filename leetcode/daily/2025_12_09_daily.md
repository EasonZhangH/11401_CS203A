# LeetCode Daily 2025/12/09 筆記

## 題目：Count Special Triplets (LeetCode 3583)

---
## 題目描述
給定一個整數陣列 `nums`，我們要計算「特殊三元組」的數量。  
特殊三元組的定義為：存在索引 \(i < j < k\)，且滿足條件：

nums[i] + nums[k] = 2 * nums[j]

最終答案需對 \(10^9 + 7\) 取模。

---

## 觀察
1. **條件轉換**  
   - 三元組的條件是「左右元素的和等於中間元素的兩倍」。
   - 換句話說，若固定中間元素 `nums[j]`，則需要找出左邊出現過的 `target = 2 * nums[j]`，以及右邊仍存在的 `target = 2 * nums[j]`。

2. **計數方式**  
   - 使用兩個哈希表：
     - `leftCount`：記錄左邊元素的出現次數。
     - `rightCount`：記錄右邊元素的出現次數。
   - 每次迭代：
     - 先將 `nums[j]` 從右邊移除（因為右邊只包含索引大於 j 的元素）。
     - 檢查 `target = 2 * nums[j]` 是否同時存在於左邊與右邊。
     - 若存在，則累加 `leftCount[target] * rightCount[target]`。

3. **模運算**  
   - 為避免溢位，結果需對 \(10^9 + 7\) 取模。

---

##  程式碼
```cpp
class Solution {
public:
    int specialTriplets(vector<int>& nums) {
        const int MOD = 1e9 + 7;
        int n = nums.size();
        if (n < 3) return 0;
        
        unordered_map<long long, int> leftCount, rightCount;
        
        // 初始化 rightCount 為所有數字的頻率
        for (int x : nums) {
            rightCount[x]++;
        }
        
        long long res = 0;
        for (int j = 0; j < n; j++) {
            // 移除當前元素，因為右邊只包含 k > j
            rightCount[nums[j]]--;
            
            // 檢查是否能形成特殊三元組
            long long target = 2LL * nums[j];
            if (leftCount.count(target) && rightCount.count(target)) {
                res = (res + 1LL * leftCount[target] * rightCount[target]) % MOD;
            }
            
            // 將當前元素加入左邊計數
            leftCount[nums[j]]++;
        }
        
        return res;
    }
};
```

---

## ⏱️ 時間複雜度分析
- **初始化**：遍歷一次陣列建立 `rightCount` → \(O(n)\)。
- **主迴圈**：對每個元素進行：
  - 哈希表查詢與更新 → 平均 \(O(1)\)。
  - 總共 \(n\) 次 → \(O(n)\)。
- **總時間複雜度**：  
  O(n)
- **空間複雜度**：  
  使用兩個哈希表存放元素頻率 → 最多 \(O(n)\)。

---

