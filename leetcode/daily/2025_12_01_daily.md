# LeetCode Daily 2025/12/01 筆記

## 題目：Count the Number of Inversions (LeetCode 3625)

### 題目描述
- 給定二維點陣列
- 計算可以形成的梯形數量
- 需要考慮平行線和平行四邊形的特殊情況

---

### 觀察
- 計算所有直線的斜率和截距
- 統計平行線的組合數
- 使用中點法計算平行四邊形數量
- 從總數中減去重複計數

---

### 程式碼 (C++)

```cpp
class Solution {
public:
    pair<double, double> cal_line(vector<vector<int>>& points, int i, int j) {
        double x1 = points[i][0], y1 = points[i][1];
        double x2 = points[j][0], y2 = points[j][1];
        if (x1 == x2)
            return {1e9, x1};
        double k = (y1 - y2) / (x1 - x2);
        double b = (x2 * y1 - x1 * y2) / (x1 - x2);
        return {k, b};
    }

    long long encode(long long x, long long y) {
        return (x << 32) ^ y;
    }

    long long encode_line(double k, double b) {
        long long kk = llround(k * 1e6);
        long long bb = llround(b * 1e6);
        return (kk << 32) ^ bb;
    }

    long long parallelograms(const vector<vector<int>>& pts) {
        unordered_map<long long, int> mp;
        int n = pts.size();
        for (int i = 0; i < n; i++) {
            long long x1 = pts[i][0], y1 = pts[i][1];
            for (int j = i + 1; j < n; j++) {
                long long x2 = pts[j][0], y2 = pts[j][1];

                long long mx = x1 + x2;
                long long my = y1 + y2;

                mp[encode(mx, my)]++;
            }
        }

        long long total = 0;
        for (auto& p : mp) {
            long long c = p.second;
            if (c >= 2) total += c * (c - 1) / 2;
        }
        return total;
    }

    int countTrapezoids(vector<vector<int>>& points) {
        int n = points.size();
        if (n < 4) return 0;

        unordered_map<double, unordered_map<double, int>> edges;
        unordered_map<long long, vector<int>> lines;

        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                auto [k, b] = cal_line(points, i, j);

                edges[k][b] += 1;

                long long id = encode_line(k, b);
                lines[id].push_back(i);
                lines[id].push_back(j);
            }
        }

        if (edges.size() == 1) return 0;

        long long ans = 0;
        for (auto& p : edges) {
            auto& bs_map = p.second;

            vector<int> bs;
            for (auto& q : bs_map) bs.push_back(q.second);

            int m = bs.size();
            for (int i = 0; i < m - 1; i++) {
                for (int j = i + 1; j < m; j++) {
                    ans += (long long)bs[i] * bs[j];
                }
            }
        }

        long long dup = parallelograms(points);

        for (auto& p : lines) {
            auto& idx = p.second;
            sort(idx.begin(), idx.end());
            idx.erase(unique(idx.begin(), idx.end()), idx.end());

            if (idx.size() >= 4) {
                vector<vector<int>> sub;
                for (int i : idx) sub.push_back(points[i]);
                dup -= parallelograms(sub);
            }
        }

        return ans - dup;
    }
};
```
